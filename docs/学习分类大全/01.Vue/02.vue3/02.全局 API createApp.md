---
title: 全局 API createApp
date: 2023-04-10 14:10:30
permalink: /pages/c2eff6/
categories: 
  - 学习分类大全
  - Vue
  - vue3
tags: 
  - vue3
author: 
  name: mby
  link: https://blog.csdn.net/weixin_44149219?type=blog
titleTag: 
---

### createApp (全局 API) <Badge text="非兼容"  type="error"/>
调用 createApp 返回一个应用实例，一个 Vue 3 中的新概念。
```js
import { createApp } from 'vue'

const app = createApp({})
```

|  2.x 全局 API	   | 3.x 实例 API (app)  |
|  ----  | ----  |
| Vue.config  | app.config |
| Vue.config.productionTip  | 移除 (见下方) |
| Vue.config.ignoredElements  | app.config.compilerOptions.isCustomElement (见下方) |
| Vue.component | app.component |
| Vue.directive  | app.directive |
| Vue.mixin  | app.mixin |
| Vue.use  | app.use (见下方)|
| Vue.prototype  | app.config.globalProperties (见下方) |
| Vue.extend  | 移除 (见下方) |


### config.productionTip 移除#
在 Vue 3.x 中，“使用生产版本”提示仅在使用“dev + full build”(包含运行时编译器并有警告的构建版本) 时才会显示。

对于 ES 模块构建版本，由于它们是与打包器一起使用的，而且在大多数情况下，CLI 或脚手架已经正确地配置了生产环境，所以本提示将不再出现。

### config.ignoredElements 替换为 config.isCustomElement
config.ignoredElements 替换为 config.isCustomElement#
引入此配置选项的目的是为了支持原生自定义元素，因此重命名可以更好地传达它的意图。同时，新选项接受一个函数，相比旧的字符串或正则表达式来说能提供更高的灵活性：

```js
// 之前
Vue.config.ignoredElements = ['my-el', /^ion-/]

// 之后
const app = createApp({})
app.config.compilerOptions.isCustomElement = (tag) => tag.startsWith('ion-')
```
<p>

<strong>重要</strong>

在 Vue 3 中，元素是否是组件的检查已转移到模板编译阶段，因此只有在使用运行时编译器时此配置选项才会生效。如果你使用的是仅运行时构建版本，则 isCustomElement 必须在构建步骤中传递给 @vue/compiler-dom ——比如，通过 vue-loader 中的 compilerOptions 选项。

- 当使用仅运行时构建版本时，如果配置了 config.compilerOptions.isCustomElement 选项，将发出警告，以指示用户该选项应该在构建步骤中传递；
- 这将是 Vue CLI 配置中新的顶层选项。</p>


### Vue.prototype 替换为 config.globalProperties#
在 Vue 2 中， Vue.prototype 通常用于添加所有组件都能访问的 property。

在 Vue 3 中与之对应的是 config.globalProperties。这些 property 将被复制到应用中，作为实例化组件的一部分。

```js
// 之前
Vue.prototype.$http = () => {}

// 之后
const app = createApp({})
app.config.globalProperties.$http = () => {}
```
使用 provide (稍后会讨论) 时，也应考虑作为 globalProperties 的替代品。

### Vue.extend 移除#
在 Vue 2.x 中，Vue.extend 曾经被用于创建一个基于 Vue 构造函数的“子类”，其参数应为一个包含组件选项的对象。在 Vue 3.x 中，我们已经没有组件构造器的概念了。应该始终使用 createApp 这个全局 API 来挂载组件：
```js
// 之前 - Vue 2

// 创建构造器
const Profile = Vue.extend({
    template: '<p>{{firstName}} {{lastName}} aka {{alias}}</p>',
    data() {
        return {
            firstName: 'Walter',
            lastName: 'White',
            alias: 'Heisenberg'
        }
    }
})
// 创建一个 Profile 的实例，并将它挂载到一个元素上
new Profile().$mount('#mount-point')
```

```js
// 之后 - Vue 3
const Profile = {
    template: '<p>{{firstName}} {{lastName}} aka {{alias}}</p>',
    data() {
        return {
            firstName: 'Walter',
            lastName: 'White',
            alias: 'Heisenberg'
        }
    }
}
Vue.createApp(Profile).mount('#mount-point')
```

###### 类型推断#
在 Vue 2 中，Vue.extend 也被用来为组件选项提供 TypeScript 类型推断。在 Vue 3 中，为了达到相同的目的，defineComponent 全局 API 可以用来作为 Vue.extend 的替代方案。

需要注意的是，虽然 defineComponent 的返回类型是一个类似构造器的类型，但是它的目的仅仅是为了 TSX 的推断。在运行时 defineComponent 里基本没有什么操作，只会原样返回该选项对象。

###### 组件继承#
在 Vue 3 中，我们强烈建议使用 组合式 API 来替代继承与 mixin。如果因为某种原因仍然需要使用组件继承，你可以使用 extends 选项 来代替 Vue.extend。

### app.use() 替代 Vue.use()

```js
const app = createApp(MyApp)
app.use(VueRouter)
```

### 挂载 App 实例

``` 
const app = createApp(MyApp)

app.component('button-counter', {
  data: () => ({
    count: 0
  }),
  template: '<button @click="count++">Clicked {{ count }} times.</button>'
})

app.directive('focus', {
  mounted: (el) => el.focus()
})

// 现在，所有通过 app.mount() 挂载的应用实例及其组件树，
// 将具有相同的 “button-counter” 组件和 “focus” 指令，
// 而不会污染全局环境
app.mount('#app')
```

### Provide / Inject

与在 2.x 根实例中使用 provide 选项类似，Vue 3 应用实例也提供了可被应用内任意组件注入的依赖项：

```js
// 在入口中
app.provide('guide', 'Vue 3 Guide')

// 在子组件中
export default {
  inject: {
    book: {
      from: 'guide'
    }
  },
  template: `<div>{{ book }}</div>`
}
```
在编写插件时使用 provide 将尤其有用，可以替代 globalProperties。


### 在应用之间共享配置

在应用之间共享配置 (如组件或指令) 的一种方法是创建工厂函数，如下所示
```js
import { createApp } from 'vue'
import Foo from './Foo.vue'
import Bar from './Bar.vue'

const createMyApp = (options) => {
  const app = createApp(options)
  app.directive('focus' /* ... */)

  return app
}

createMyApp(Foo).mount('#foo')
createMyApp(Bar).mount('#bar')
```
现在，Foo 和 Bar 实例及其后代中都可以使用 focus 指令。